import itertools
from collections import defaultdict

from abc import abstractmethod
from logging import Logger
import numpy as np
from typing import List, Optional, Type

import rte.python.profiler as prof
from decision_making.src.exceptions import raises
from decision_making.src.global_constants import LANE_CHANGE_TIME_COMPLETION_TARGET, MIN_LANE_CHANGE_ACTION_TIME
from decision_making.src.planning.behavioral.state.behavioral_grid_state import BehavioralGridState
from decision_making.src.planning.behavioral.state.lane_change_state import LaneChangeStatus
from decision_making.src.planning.behavioral.data_objects import ActionRecipe
from decision_making.src.planning.behavioral.data_objects import ActionSpec
from decision_making.src.planning.behavioral.filtering.recipe_filtering import RecipeFiltering


class ActionSpace:
    def __init__(self, logger: Logger, recipes: List[ActionRecipe], recipe_filtering: Optional[RecipeFiltering] = None):
        """
        Abstract class for Action-Space implementations. Implementations should include actions enumeration, filtering
         and specification.
        :param logger: dedicated logger implementation
        :param recipes: list of recipes that define the scope of an ActionSpace implementation
        :param recipe_filtering: RecipeFiltering object that holds the logic for filtering recipes
        """
        self.logger = logger
        self._recipes = recipes
        self._recipe_filtering = recipe_filtering or RecipeFiltering(None, logger)

    @property
    def action_space_size(self) -> int:
        return len(self._recipes)

    @property
    def recipes(self) -> List[ActionRecipe]:
        """returns all recipes generated by an ActionSpace implementation"""
        return self._recipes

    @property
    @abstractmethod
    def recipe_classes(self) -> List[Type]:
        """lists all recipe class types that an ActionSpace implementation can create"""
        pass

    @prof.ProfileFunction()
    def filter_recipe(self, action_recipe: ActionRecipe, behavioral_state: BehavioralGridState) -> bool:
        """
        For a given recipe (and a state), returns true if the recipe passes all filters in self._recipe_filtering
        :param action_recipe: recipe to validate
        :param behavioral_state: current state of the world
        :return: true if recipe passes all filters, false otherwise
        """
        return self._recipe_filtering.filter_recipe(action_recipe, behavioral_state)

    @prof.ProfileFunction()
    def filter_recipes(self, action_recipes: List[ActionRecipe], behavioral_state: BehavioralGridState) -> List[bool]:
        """
        For a given list of recipes (and a state) - for each recipe, returns true if the recipe passes all filters
        in self._recipe_filtering
        :param action_recipes: recipes to validate
        :param behavioral_state: current state of the world
        :return: list - true where a recipe passes all filters, false otherwise
        """
        return self._recipe_filtering.filter_recipes(action_recipes, behavioral_state)

    def specify_goal(self, action_recipe: ActionRecipe, behavioral_state: BehavioralGridState) -> Optional[ActionSpec]:
        return self.specify_goals([action_recipe], behavioral_state)[0]

    @abstractmethod
    def specify_goals(self, action_recipes: List[ActionRecipe], behavioral_state: BehavioralGridState) -> List[Optional[ActionSpec]]:
        """
        This method's purpose is to specify the enumerated actions (recipes) that the agent can take.
        Each semantic action (ActionRecipe) is translated into a terminal state specification (ActionSpec).
        :param action_recipes: an enumerated semantic action [ActionRecipe].
        :param behavioral_state: a Frenet state of ego at initial point
        :return: semantic action specification [ActionSpec] or [None] if recipe can't be specified.
        """
        pass

    def modify_lane_change_time(self, action_recipes: List[ActionRecipe], behavioral_state: BehavioralGridState, T: np.ndarray) -> None:
        """
        Find the lane change actions and override the action spec. time for these actions so that we meet the lane change time
        requirement. Note that the argument T is mutable so it's passed by reference here. When we modify it here, we're actually modifying
        the object in the calling function. That means we do not have to return it.
        :param action_recipes: list of action recipes
        :param behavioral_state: current state of the world
        :param T: action spec. times for every action recipe
        :return:
        """
        action_recipe_relative_lanes = [recipe.relative_lane for recipe in action_recipes]
        lane_change_mask = behavioral_state.lane_change_state.get_lane_change_mask(action_recipe_relative_lanes,
                                                                                   behavioral_state.extended_lane_frames)

        # Override mask values if T is nan for that recipe
        lane_change_mask = [mask if ~np.isnan(T[i]) else False for i, mask in enumerate(lane_change_mask)]

        if behavioral_state.lane_change_state.status == LaneChangeStatus.AnalyzingSafety:
            # This will be reached before a lane change has begun
            T[lane_change_mask] = LANE_CHANGE_TIME_COMPLETION_TARGET
        else:
            T[lane_change_mask] = max(MIN_LANE_CHANGE_ACTION_TIME, LANE_CHANGE_TIME_COMPLETION_TARGET
                                                                   + behavioral_state.lane_change_state.lane_change_start_time
                                                                   - behavioral_state.ego_state.timestamp_in_sec)


class ActionSpaceContainer(ActionSpace):
    def __init__(self, logger: Logger, action_spaces: List[ActionSpace]):
        """
        This class acts as a container for action_spaces and is responsible for filtering and specifying each recipe with
        the respective class (e.g. StaticActionSpace or DynamicActionSpace)
        :param logger: dedicated logger implementation
        :param action_spaces: a list of various implementations of the interface ActionSpace, containing recipes (List[ActionSpace])
        """
        super().__init__(logger, [])
        self._action_spaces = action_spaces
        self._recipe_handler = {recipe_class: aspace
                                for aspace in action_spaces
                                for recipe_class in aspace.recipe_classes}

    @property
    def action_space_size(self) -> int:
        return sum(aspace.action_space_size for aspace in self._action_spaces)

    @property
    def recipes(self) -> List[ActionRecipe]:
        return list(itertools.chain.from_iterable(aspace.recipes for aspace in self._action_spaces))

    @property
    def recipe_classes(self) -> List:
        return list(itertools.chain.from_iterable(aspace.recipe_classes for aspace in self._action_spaces))

    @raises(NotImplemented)
    def specify_goals(self, action_recipes: List[ActionRecipe], behavioral_state: BehavioralGridState) -> \
            List[Optional[ActionSpec]]:
        grouped_actions = defaultdict(list)
        grouped_idxs = defaultdict(list)
        for idx, recipe in enumerate(action_recipes):
            grouped_actions[recipe.__class__].append(recipe)
            grouped_idxs[recipe.__class__].append(idx)

        indexed_action_specs = list(itertools.chain.from_iterable(
            [zip(grouped_idxs[action_class], self._recipe_handler[action_class].specify_goals(action_list, behavioral_state))
             for action_class, action_list in grouped_actions.items()]))

        # returns action_specs, sorted by their initial recipe ordering
        return [action for idx, action in sorted(indexed_action_specs, key=lambda idx_action: idx_action[0])]

    @raises(NotImplemented)
    def filter_recipe(self, action_recipe: ActionRecipe, behavioral_state: BehavioralGridState) -> bool:
        return self._recipe_handler[action_recipe.__class__].filter_recipe(action_recipe, behavioral_state)

    # TODO: figure out how to remove the for loop for better efficiency and stay consistent with ordering
    @raises(NotImplemented)
    def filter_recipes(self, action_recipes: List[ActionRecipe], behavioral_state: BehavioralGridState):
        grouped_actions = defaultdict(list)
        grouped_idxs = defaultdict(list)
        for idx, recipe in enumerate(action_recipes):
            grouped_actions[recipe.__class__].append(recipe)
            grouped_idxs[recipe.__class__].append(idx)

        indexed_action_specs = list(itertools.chain.from_iterable(
            [zip(grouped_idxs[action_class], self._recipe_handler[action_class].filter_recipes(action_list, behavioral_state))
             for action_class, action_list in grouped_actions.items()]))

        # returns action_specs, sorted by their initial recipe ordering
        return [action for idx, action in sorted(indexed_action_specs, key=lambda idx_action: idx_action[0])]
